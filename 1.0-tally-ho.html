<script>
    pageScope.bases = [ 3, 5 ];

    pageScope.orb = new Orbitation( pageScope.bases, { truncated: false } );

    pageScope.serialText = ( coord, serial ) => `${ serial }<sub>(${ coord.join( ',' ) })</sub>`;
    pageScope.coordText = ( coord, serial ) => `(${ coord.join( ',' ) })<sub>${ serial }</sub>`;

    const factorial = n => !(n > 1) ? 1 : factorial(n - 1) * n;
    const fff = (n) => factorial( n ) * n * ( n - 1 ) / 2;

    pageScope.ranks = fff( pageScope.bases.length );

</script>

<h2>Specification</h2>
Consider a box with <a class="eval" title="pageScope.bases.length">RANK</a> sides: for example <a class="eval" title="pageScope.orb.specification()">SPEC</a>;
it contains <a class="eval" title="pageScope.orb.volume">VOLUME</a> points.

<ul>
    <li>
        The specification "<a class="eval" title="pageScope.orb.specification()">SPEC</a>" means
        "<a class="eval" title="pageScope.bases[0]">B0</a> copies of a collection of <a class="eval" title="pageScope.bases[1]">B1</a> points".
    </li>
    <li>
        The specification
        "<a class="eval" title="pageScope.orb.specification( true )">SPEC</a>" means
        "<a class="eval" title="pageScope.bases[1]">B1</a> copies of a collection of <a class="eval" title="pageScope.bases[0]">B0</a> points".
    </li>
</ul>

A box specification can be laid-out in a packing table, given that:

<ol type="i">
    <li>
        The bottom left point is identified as the origin (and then the top right point will be the terminal).
    </li>
    <li>
        The points are counted in sequence from the origin: left-to-right, bottom-to-top, (in-to-out).
    </li>
    <li>The index of each point is the count of points up to, but not including, the current point.</li>
    <li>The coordinate of each point is the sequence of places such that:
        <ul>
            <li>the right-most place counts left-to-right only</li>
            <li>the second right place counts down-to-up only</li>
            <li>(the third right place counts in-to-out only).</li>
        </ul>
    </li>
</ol>

A box with <a class="eval" title="pageScope.bases.length">RANK</a> sides will have <a class="eval" title="pageScope.ranks">RANKS</a> packing table layouts,
each the reverse specification of the other.

<table>
    <tr>
        <td class="evalNode" title="boxPackingTable( pageScope.bases, pageScope.serialText )"></td>
        <td class="evalNode" title="boxPackingTable( [ ...pageScope.bases ].reverse(), pageScope.serialText )"></td>
    </tr>
</table>

<div class="pagebreak"></div>

A packing table layout can be twisted by reflecting its points in the diagonal between the origin and terminal points
and then reversing the coordinate for each point.

<table>
    <tr>
        <td class="evalNode" title="boxPackingTable( pageScope.bases, pageScope.serialText )"></td>
        <td class="evalNode" title="boxPackingTable( pageScope.bases, pageScope.serialText, true )"></td>
    </tr>
</table>

Twisting a box specification layout makes it the same shape as the layout of the reverse specification.

<table>
    <tr>
        <td class="evalNode" title="boxPackingTable( [ ...pageScope.bases ].reverse(), pageScope.serialText, true )"></td>
        <td class="evalNode" title="boxPackingTable( pageScope.bases, pageScope.serialText )"></td>
    </tr>
</table>


The two layouts now have the same coordinates in the same places, but not always the same index values.
<br/>
<br/>

For example;
<ul>
    <li><span class="eval" title="pageScope
        .orb
        .cycles( pageScope.bases[1] )
        .filter( cycle => cycle[0] == 1 )
        .flatMap( cycle => cycle.map( ( c, i ) => `${ c }${ i + 1 == cycle.length ? ' goes back to 1' : '  goes to ' + cycle[ i + 1 ] + ', and ' }` ) )
        .join( '' )"></span>, completing a cycle of length <a class="eval" title="pageScope.orb.order( pageScope.bases[1] )"></a>.</li>
    <li><span class="eval" title="pageScope
        .orb
        .cycles( pageScope.bases[1] )
        .filter( cycle => cycle.length > 1 )
        .filter( cycle => cycle[0] != 1 )
        .flatMap( cycle => cycle.map( ( c, i ) => `${ c }${ i + 1 == cycle.length ? ' goes back to 1' : '  goes to ' + cycle[ i + 1 ] + ', and ' }` ) )
        .join( '' )"></span>, completing another cycle of length <a class="eval" title="pageScope.orb.order( pageScope.bases[1] )"></a>.</li>
</ul>

However:

<ul>
    <li><span class="eval" title="pageScope
        .orb
        .cycles( 5 )
        .filter( cycle => cycle.length == 1 )
        .flatMap( cycle => cycle.map( ( c, i ) => `${ c } goes to ${ c }` ) )
        .join( ', ' )"></span>; cycles of length 1, or fixed points.</li>
</ul>

This is written more succinctly as an expression in cycle notation:
<br/>
<br/>

<span class="evalNode" title="pageScope.orb.cyclesHtml( 5 )"></span>
<br/><br/>

NB: It's useful to retain the fixed points in the expression, even though they are usually elided,
so that every point is represented and hence the total number of points is apparent.

<div class="pagebreak"></div>

The cycles can also be written in terms of coordinates:
<br/>
<br/>

<span class="evalNode" title="pageScope.orb.coordCyclesHtml( 5 )"></span>


<script>
    /*
    const boxFn = ( coord, serial, transparency = 0.95 ) => {
        return ( serial == 0 )
            ? createBoxShape( new Array( 3 ).fill( 0.7 ), "red", 0.8 )
            : createBoxShape( new Array( 3 ).fill( 0.6 ), "blue", transparency );
    };

    const textFn = ( coord, serial ) => createTextShape( `${ serial } (${ [ ...coord ].reverse().join( ',' ) })`, { "size": 0.3, 'solid': false } );
    const serialTextFn = ( coord, serial ) => createTextShape( `${ serial }`, { "size": 0.3, 'solid': false } );
    const coordTextFn = ( coord, serial ) => createTextShape( `(${ [ ...coord ].reverse().join( ',' ) })`, { "size": 0.3, 'solid': true } );


    var cellFn = ( coord, serial ) => [
        boxFn( coord, serial ),
        serialTextFn( coord, serial )
    ];

    var sides = [ 5, 3 ];

    const serialText = ( coord, serial ) => `${ serial }<sub>(${ coord.join( ',' ) })</sub>`;
    const coordText = ( coord, serial ) => `(${ coord.join( ',' ) })`;


    const bpt2 = boxPackingTable( [ 3, 5 ], serialText, true );
    document.getElementById( 'cuboid-packing-table-2' ).appendChild( bpt2 );

    const bpt3 = boxPackingTable( [ 5, 3 ], serialText, false );
    document.getElementById( 'cuboid-packing-table-3' ).appendChild( bpt3 );


    const x3domNode0 = appendX3DomNode(
        createGridOfCells( sides, { offset: [ -2, 0, 0 ], scaleUnit: [ 2, 2, 0.1 ] },
            ( coord, serial ) => [
                boxFn( coord, serial ),
                coordTextFn( coord, serial )
            ] ),
        { containerId: 'cuboid-coords' }
    );

    const x3domNode1 = appendX3DomNode(
        createGridOfCells( sides, { offset: [ -2, 0, 0 ], scaleUnit: [ 2, 2, 0.1 ] }, cellFn ),
        { containerId: 'cuboid-landscape' } );

    const sides2 = [ ...sides ].reverse();

    const x3domNode2 = appendX3DomNode(
        createGridOfCells( sides2, { offset: [ 0, -0.5, 0 ], scaleUnit: [ 1.5, 1.5, 0.1 ] }, cellFn ),
        { containerId: 'cuboid-portrait' } );


    insertOrbitation( sides );
    */
</script>