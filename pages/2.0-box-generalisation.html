<script>
    if ( urlParam.has( "bases2d" ) ) {
        pageScope.bases2d = urlParam.get( "bases2d" ).split( "," ).map( b => Number( b ) );
    } else {
        pageScope.bases2d = [ 3, 4 ];
    }

    pageScope.orb2d = new Orbitation( pageScope.bases2d, { truncated: false } );

    if ( urlParam.has( "bases3d" ) ) {
        pageScope.bases3d = urlParam.get( "bases3d" ).split( "," ).map( b => Number( b ) );
    } else {
        pageScope.bases3d = [ 2, 3, 4 ];
    }

    pageScope.orb3d = new Orbitation( pageScope.bases3d, { truncated: false } );

    if ( urlParam.has( "bases4d" ) ) {
        pageScope.bases4d = urlParam.get( "bases4d" ).split( "," ).map( b => Number( b ) );
    } else {
        pageScope.bases4d = [ 2, 3, 4, 5 ];
    }

    pageScope.orb4d = new Orbitation( pageScope.bases4d, { truncated: false } );

    pageScope.serialText = ( coord, serial ) => `${ serial }<sub>(${ coord.join( ',' ) })</sub>`;
    pageScope.coordText = ( coord, serial ) => `(${ coord.join( ',' ) })<sub>${ serial }</sub>`;

    pageScope.letters = "abcdefghijklmnopqrstuvwxyz";
    pageScope.greek = "풤쒩풦풧풨풩풪풫풬풭풮쮍쫥픠픡픢픣픤픥픦픧픨";
</script>

<h2>Generalisation</h2>

A box with <code>n</code> dimensions, or bases, has <code>n!</code> specifications,
because each specification is a permutation of the bases,
and each specification can be compared with itself and every other specification
to produce <code>(n!)<sup>2</sup></code> actions (i.e. cycles expressions).
<br/>
<br/>

Of these, <code>n!</code> will be self comparisons,
identity actions that don't move any points and are self-inverse,
and the remainder form <code>&frac12;((n!)<sup>2</sup> - n!)</code> pairs of distinct mutually inverse actions
that move at least two points.
<br/>
<br/>

<table class="evalNode generalization-table" title="[
        [
            'Box<br/>',
            'Base<br/>Permutation',
            'Dimensions<br/><code>n</code>',
            'Specs<br/><code>n!</code>',
            'Actions<br/><code>(n!)<sup>2</sup></code>',
            'Identities<br/><code>n!</code>',
            'Distinct Inverse Action Pairs<br/><code>&frac12;n!(n!-1)</code>',
        ]
            .map( h => reify( 'th', {}, [], [ c => c.innerHTML = h ] ) ),

        ...[
                [ 'a', 'b' ],
                [ 'a', 'b', 'c' ],
                [ 'a', 'b', 'c', 'd' ],
                [ 'a', 'b', 'c', 'd', 'e' ],
                [ 'a', 'b', 'c', 'd', 'e', 'f' ],
                [ 'a', 'b', 'c', 'd', 'e', 'f', 'g' ]]
            .map( bases => [
                    bases.join( '<code>x</code>' ),
                    `[${ aoi( bases.length ).join( ',' ) }]`,
                    bases.length,
                    factorial( bases.length ),
                    factorial( bases.length )**2,
                    factorial( bases.length ),
                    (1/2) * ( factorial( bases.length )**2 - factorial( bases.length ) )
                ] )
            .map( row => row.map( cell => reify( 'td', {}, [], [ c => c.innerHTML = cell ] ) ) )

    ]
        .map( cells => reify( 'tr', {}, cells ) )
"></table>
<br/>
<br/>

<h3>Symbology</h3>

Each specification can be assigned a unique two symbol coordinate such that:
<ul>
    <li>
        The first symbol is shared by both a specification and its corresponding reverse specification (i.e. mutually inverse actions).
        <br/>
        e.g.: 풤, , 풥, 풦, etc.
    </li>
    <li>
        The second symbol distinguishes, perhaps arbitrarily, between the two actions in a mutually inverse pair.
        <br/>
        e.g.: up 游맨, and down 游맪.
    </li>
</ul>

A two dimensional box has two symbol coordinates as follows:
<br/>
<br/>

<table class="generalization-table">
    <tr><th>Box<br/>Specification</th><th>Base<br/>Permutation</th><th>Symbol<br/>Coordinate</th></tr>
    <tr><td>a<code>x</code>b</td><td>[0,1]</td><td>풤游맪</td></tr>
    <tr><td>b<code>x</code>a</td><td>[1,0]</td><td>풤游맨</td></tr>
</table>
<br/>

The four actions of a two dimensional box are labelled as follows:
<br/>
<br/>

<table class="generalization-table">
    <tr><th>Action Symbols</th><th>Comparison</th><th>Label</th><th>Alias</th></tr>
    <tr><td>풤游맪풤游맪</td><td>[0,1]-[0,1]</td><td><code>e<sub>0</sub></code></td><td>e</td></tr>
    <tr><td>풤游맨풤游맨</td><td>[1,0]-[1,0]</td><td><code>e<sub>1</sub></code></td><td>e</td></tr>
    <tr><td>풤游맪풤游맨</td><td>[0,1]-[1,0]</td><td><code>z<sub>0</sub></code></td><td>(풤游맨풤游맪)<sup>-1</sup></td></tr>
    <tr><td>풤游맨풤游맪</td><td>[1,0]-[0,1]</td><td><code>z<sub>0</sub><sup>-1</sup></code></td><td>(풤游맪풤游맨)<sup>-1</sup></td></tr>
</table>
<br/>

A three dimensional box has six specifications
and in this case second symbols can be aligned
so that specifications which are rotations of each other
have the same second symbol.
<br/>
<br/>

For example:
<br/>
<br/>
<script>
    pageScope.basePerms = [
        [ 0, 1, 2 ],
        [ 1, 2, 0 ],
        [ 2, 0, 1 ],
        [ 2, 1, 0 ],
        [ 0, 2, 1 ],
        [ 1, 0, 2 ],
    ];
</script>
<table class="evalNode generalization-table" title="[
        [
            'Spec<br/>',
            'Base<br/>Permutation',
            'Symbols'
        ]
            .map( h => reify( 'th', {}, [], [ c => c.innerHTML = h ] ) ),

        ...pageScope.basePerms.map(
            ( basePerm, i ) => [ basePerm.map( b => pageScope.letters[b] ).join( '<code>x</code>' ),
                `[${ basePerm.join( ',' ) }]`,
                `${ pageScope.greek[ i % 3 ] }${ i < 3 ? '游맪' : '游맨' }`
            ].map( cell => reify( 'td', {}, [], [ c => c.innerHTML = cell ] ) )
        ),


    ].map( cells => reify( 'tr', {}, cells ) )"></table>
<br/>



