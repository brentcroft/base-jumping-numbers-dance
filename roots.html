<html>
<head>
    <meta charset="utf-8"/>

    <script type="text/javascript" src="js/x3dom.js"></script>
    <link rel="stylesheet" type="text/html" href="js/x3dom.css"/>

    <link rel="stylesheet" href="css/orbits.css">

    <!-- model -->
    <script type="text/javascript" src="js/toggles.js"></script>
    <script type="text/javascript" src="js/data.js"></script>
    <script type="text/javascript" src="js/orbits.js"></script>
    <script type="text/javascript" src="js/index.js"></script>
    <script type="text/javascript" src="js/group.js"></script>
    <script type="text/javascript" src="js/expression.js"></script>

    <script type="text/javascript" src="js/orbitation.js"></script>
    <script type="text/javascript" src="js/bitmap.js"></script>
    <script type="text/javascript" src="js/glyphs.js"></script>


    <!-- ui -->
    <script type="text/javascript" src="js/factors.js"></script>
    <script type="text/javascript" src="js/colors.js"></script>
    <script type="text/javascript" src="js/htmltable.js"></script>
    <script type="text/javascript" src="js/3d.js"></script>

    <!-- page -->
    <script type="text/javascript">
        var instance = 0;
        function sendResult( result, sourceElement, excludes = [] ) {
            if ( !result ) {
                return;
            }
            var tag = null;
            var items = 0;

            function decomposeValue( label, value ) {
                return reify(
                    "div",
                    { class: 'summaryLeft' },
                    [],
                    [ d => d.innerHTML = `${ label ? label + ': ' : '' }${ value }` ]
                );
            }

            function decomposeObject( label, value ) {
                // do non-arrays first
                return reify( "div", {}, [
                    decomposeValue( null, label ),
                    ...Object
                        .entries( value )
                        .filter( ([k,v]) => !excludes.includes( k ) )
                        .filter( ([k,v]) => !Array.isArray( v ) )
                        .map( ([k,v]) => decomposeValue( k, v ) ),
                    ...Object
                        .entries( value )
                        .filter( ([k,v]) => !excludes.includes( k ) )
                        .filter( ([k,v]) => Array.isArray( v ) )
                        .map( ([k,v]) => decomposeArray( k, v ) )
                ] );
            }
            function decomposeArray( key, value ) {
                const firstElement = value[ 0 ];
                const isNested = Array.isArray( firstElement );
                return reify(
                    "textarea", { class: 'scriptPanelTextArea', rows: isNested ? Math.min( 20, 1 + value.length ) : 2, disabled: 'disabled' }, [], [
                        d => d.value = key + ":\n" +
                           ( isNested
                                ? value
                                    .map( r => r
                                        .map( a => String( a ).padStart( 2, ' ' ) )
                                        .join( ', ' ) )
                                    .join( '\n' )
                                : Number.isInteger( firstElement )
                                    ? value.join( ', ' )
                                    : value.join( '\n' ))
                    ] );
            }

            function decompose( result ) {
                const key = `<br/><hr/><b>result:</b> ${ new Date().toISOString() }<br/>`;
                return Array.isArray( result )
                    ? decomposeArray( key, result )
                    : result instanceof Object
                        ? decomposeObject( key, result )
                        : decomposeValue( null, result );
            }

            var targetElement = reify(
                "div",
                { class: 'scriptPanelResult' },
                [ decompose( result ) ]
            );

            sourceElement.parentNode.appendChild( targetElement );
        }

        function show( result, excludes ) {
            const sourceId = 'calculationScript';
            const sourceElement = document.getElementById( sourceId );
            sendResult( result, sourceElement, excludes );
        }

        function calculate( script, sourceElement ) {
            if ( document.getElementById( 'clearOnCalculate' ).checked ) {
                clearResults();
            }
            try {
                show( eval( script ) );
            } catch ( e ) {
                show( `<font color='red'>${ e }</font>` );
                throw e;
            }
        }

        function clearResults() {
            document
                .querySelectorAll( '.scriptPanelResult' )
                .forEach( element => element.parentNode.removeChild( element ) );
        }

        function calculateNow() {
            const sourceId = 'calculationScript';
            const sourceElement = document.getElementById( sourceId );

            calculate( sourceElement.value, 'calculationResult' );
        }

        function glyphs( perm, maxBar, width, height ) {
            const sourceId = 'calculationScript';
            const sourceElement = document.getElementById( sourceId );
            writeBarGlyphs( sourceElement, perm, maxBar, width, height + 25 );
        }

        function rootSummary( base, stride, param = {} ) {
            try {
                const clockfaces = getClockfaces(  base, stride );
                return [ stride, getOrbits( clockfaces )
                    .filter( o => o.length > 1 )
                    .map( o => `( ${ o.join( ' ' ) } )` )
                    .join('') ];
            } catch ( e ) {
                show( param.stack
                    ? { base: base, stride: stride, '!': e.stack.replaceAll( '\n', '<br/>' ) }
                    : { base: base, stride: stride, '!': e } );
            }
        }

        function oneRoots( base, stride, w, h, param = {} ) {
            try {
                const r = rootsInfo( base, stride )
                show( r, param.excludes );
                if ( param.glyphs ) {
                    r[ 'roots' ].forEach( x => glyphs( x, base, w, h ) );
                }
            } catch ( e ) {
                show( param.stack
                    ? { base: base, stride: stride, '!': e.stack.replaceAll( '\n', '<br/>' ) }
                    : { base: base, stride: stride, '!': e } );
            }
        }

        function allRoots( base, w, h, param = {} ) {
            aoi( base )
                // drop strides 0, 1
               .splice( 2 )
               .forEach( stride => oneRoots( base, stride, w, h, param ) );
        }


        function plot( points, iterations = 100, tickTime = 100 ) {

            const x3dRoot = reify(
                "x3d",
                { "width": "600", "height": "600" },
                [
                    reify(
                        "scene",
                        { "id": "testContainer001_plot_scene_root" },
                        [
                            reify(
                                "collision",
                                { "enabled": "false", "isactive": "true" },
                                points.map( p => p.shape )
                            )
                        ]
                    )
                ]
            );

            const sourceId = 'calculationScript';
            const sourceElement = document.getElementById( sourceId );

            sourceElement.parentNode.appendChild( reify( "div", { "class": "scriptPanelResult, resizable" }, [ x3dRoot ] ) );

            x3dom.reload();

            const force = ( link, point ) => {
                const d = displacement( link[0].coord, point.coord );

                const r2 = euclideanDistance2( d );
                const r = Math.sqrt( r2 );
                const u = d.map( x => x / r );

                const q = 1 / r;

                const inverseRodLength = 8;
                const squareRodLength = 2;
                const cubeRodLength = 1;

                var delta = 0;

                switch( link[1] ) {
                    case -1:
                        delta = 0.1 * ( inverseRodLength - r );
                        break;
                    case 1:
                        delta = -0.0001 * q;
                        break;
                    case 2:
                        delta = 0.02 * ( squareRodLength - r );
                        break;
                    case 3:
                        delta = 0.03 * ( cubeRodLength - r );
                        break;
                    default:
                        throw new Error( `Unexpected link exponent: ${ link[ 1 ] }` );
                }

                return scale( u, delta );
            };


            const origin = {
                coord: [ 0, 0, 0 ]
            };

            const tick = ( iteration ) => {

                points.forEach( p => p.netForce = [ 0, 0, 0 ] );

                points
                    .forEach( p => {
                        const forceToOrigin = force( [ origin, 1 ], p );
                        p.netForce = [
                            p.netForce,
                            forceToOrigin,
                            ...p.links
                                .map( link => {
                                    const localForce = force( link, p );
                                    // equal and opposite
                                    link[0].netForce = subtraction( link[0].netForce, localForce );
                                    return localForce;
                                } )
                        ].reduce( ( a, c ) => addition( a, c ), [ 0, 0, 0 ] )
                    } );
                points
                    .forEach( p => {
                        const nextCoord = addition( p.netForce, p.coord );
                        p.coord = nextCoord;
                        p.shape.setAttribute( "translation", nextCoord.join( ' ' ) );
                    } );

                points
                    .forEach( p => {
                        p.shapeLinks
                            .forEach( shapeLink => {
                                const [ linkPoint, exp, transformTranslation, transformRotation, cylinder ] = shapeLink;
                                const [ centre, rotationAxis, rotationAngle, height ] = getCylinderData( p, linkPoint );

                                transformTranslation.setAttribute( "translation", centre.join( ' ' ) );
                                transformRotation.setAttribute( "rotation", rotationAxis.join( ' ' ) + ' ' + rotationAngle );
                                cylinder.setAttribute( "height", String( height) );
                            } );


                    } );

                if ( iteration > 0 ) {
                    setTimeout( tick, tickTime, iteration - 1 );
                }
            };

            if ( iterations > 0 ) {
                setTimeout( tick, tickTime, iterations );
            }
        }
    </script>

    <style>
        .scriptPanel {
            width: 100%;
        }
        .scriptPanelResult {
        }
        .scriptPanelTextArea {
            width: 100%;
            white-space: pre;
            overflow-wrap: normal;
            overflow-x: scroll;
        }
        .symbol-details { font-size: 90%; border-top: solid 1px black; border-bottom: solid 1px black }
        .symbol-details tr { vertical-align: top; }
        .symbol-details tr:nth-child(even) { background: Ivory; }
        .symbol-details tr:nth-child(odd) { background: WhiteSmoke; }
        .symbol-details tr > td { border-top: 1px black dotted; }

        .resizable {
            overflow-wrap: normal;
            overflow-x: scroll;
        }
        .leftFlow {
           float: left;
        }
        .rightFlow {
           float: right;
        }

    </style>

</head>
<body onload="calculateNow()">
    <input type="button" value="eval" onclick="calculateNow()"/>
    <input type="button" value="clear" onclick="clearResults()"/>
    <label class="summaryLeft">clear on calculate<input type="checkbox" checked="checked" id="clearOnCalculate"/></label>
    <br/>
    <textarea id="calculationScript" class="scriptPanel" rows="6">const orb = new Orbitation( [ 2, 2, 2, 3 ] );
show( orb.fragmentsBlock() );
show( orb.htmlTable() );
show( "<hr class='pagebreak' />" );
show( orb.symbolsTable() );
plot( orb.x3domGroup(), 10000, 0 );</textarea>
</body>
</html>