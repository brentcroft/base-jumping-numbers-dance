<html>
<head>
    <meta charset="utf-8"/>

    <script type="text/javascript" src="js/x3dom.js"></script>
    <link rel="stylesheet" type="text/html" href="js/x3dom.css"/>

    <link rel="stylesheet" href="css/orbits.css">

    <!-- model -->
    <script type="text/javascript" src="js/toggles.js"></script>
    <script type="text/javascript" src="js/data.js"></script>
    <script type="text/javascript" src="js/orbits.js"></script>
    <script type="text/javascript" src="js/index.js"></script>
    <script type="text/javascript" src="js/group.js"></script>
    <script type="text/javascript" src="js/expression.js"></script>

    <script type="text/javascript" src="js/orbitation.js"></script>
    <script type="text/javascript" src="js/bitmap.js"></script>
    <script type="text/javascript" src="js/glyphs.js"></script>

    <script type="text/javascript" src="js/forces.js"></script>

    <!-- ui -->
    <script type="text/javascript" src="js/factors.js"></script>
    <script type="text/javascript" src="js/colors.js"></script>
    <script type="text/javascript" src="js/htmltable.js"></script>
    <script type="text/javascript" src="js/3d.js"></script>

    <!-- page -->
    <script type="text/javascript">
        var instance = 0;
        function sendResult( result, sourceElement, param = {} ) {
            if ( !result ) {
                return;
            }
            var tag = null;
            var items = 0;
            const excludes = param.excludes | [];

            function decomposeValue( label, value ) {
                return reify(
                    "div",
                    { class: 'summaryLeft' },
                    [],
                    [ d => d.innerHTML = `${ label ? label + ': ' : '' }${ value }` ]
                );
            }

            function decomposeObject( label, value ) {
                // do non-arrays first
                return reify( "div", {}, [
                    decomposeValue( null, label ),
                    ...Object
                        .entries( value )
                        .filter( ([k,v]) => !excludes.includes( k ) )
                        .filter( ([k,v]) => !Array.isArray( v ) )
                        .map( ([k,v]) => decomposeValue( k, v ) ),
                    ...Object
                        .entries( value )
                        .filter( ([k,v]) => !excludes.includes( k ) )
                        .filter( ([k,v]) => Array.isArray( v ) )
                        .map( ([k,v]) => decomposeArray( k, v ) )
                ] );
            }
            function decomposeArray( key, value ) {
                const firstElement = value[ 0 ];
                const isNested = Array.isArray( firstElement );
                return reify(
                    "textarea", { class: 'scriptPanelTextArea', rows: isNested ? Math.min( 20, 1 + value.length ) : 2, disabled: 'disabled' }, [], [
                        d => d.value = key + ":\n" +
                           ( isNested
                                ? value
                                    .map( r => r
                                        .map( a => String( a ).padStart( 2, ' ' ) )
                                        .join( ', ' ) )
                                    .join( '\n' )
                                : Number.isInteger( firstElement )
                                    ? value.join( ', ' )
                                    : value.join( '\n' ))
                    ] );
            }

            function decompose( result ) {
                const key = `<br/><hr/><b>result:</b> ${ new Date().toISOString() }<br/>`;
                return Array.isArray( result )
                    ? decomposeArray( key, result )
                    : result instanceof Object
                        ? decomposeObject( key, result )
                        : decomposeValue( null, result );
            }

            const css = ( param.css || [] );
            if ( !css.includes( 'rightFlow' ) ) {
                css.push( 'leftFlow' );
            }

            const cssClasses = [ 'scriptPanelResult', ...css ];

            var targetElement = reify(
                "div",
                { class: cssClasses.join( ',' ) },
                [ decompose( result ) ]
            );

            sourceElement.parentNode.appendChild( targetElement );
        }

        function pagebreak() {
            const sourceId = 'calculationScript';
            const sourceElement = document.getElementById( sourceId );

            var targetElement = reify( "div", { class: 'pagebreak' }, [] );

            sourceElement.parentNode.appendChild( targetElement );
        }

        function show( result, param ) {
            const sourceId = 'calculationScript';
            const sourceElement = document.getElementById( sourceId );
            sendResult( result, sourceElement, param );
        }

        function calculate( script, sourceElement ) {
            if ( document.getElementById( 'clearOnCalculate' ).checked ) {
                clearResults();
            }
            try {
                const result = eval( script );
                show( result );
            } catch ( e ) {
                show( `<font color='red'>${ e }</font>` );
                throw e;
            }
        }

        function clearResults() {
            document
                .querySelectorAll( '.scriptPanelResult' )
                .forEach( element => element.parentNode.removeChild( element ) );
        }

        function calculateNow() {
            const sourceId = 'calculationScript';
            const sourceElement = document.getElementById( sourceId );

            calculate( sourceElement.value, 'calculationResult' );
        }

        function glyphs( perm, maxBar, width, height ) {
            const sourceId = 'calculationScript';
            const sourceElement = document.getElementById( sourceId );
            writeBarGlyphs( sourceElement, perm, maxBar, width, height + 25 );
        }

        function rootSummary( base, stride, param = {} ) {
            try {
                const clockfaces = getClockfaces(  base, stride );
                return [ stride, getOrbits( clockfaces )
                    .filter( o => o.length > 1 )
                    .map( o => `( ${ o.join( ' ' ) } )` )
                    .join('') ];
            } catch ( e ) {
                show( param.stack
                    ? { base: base, stride: stride, '!': e.stack.replaceAll( '\n', '<br/>' ) }
                    : { base: base, stride: stride, '!': e } );
            }
        }

        function oneRoots( base, stride, w, h, param = {} ) {
            try {
                const r = rootsInfo( base, stride )
                show( r, param );
                if ( param.glyphs ) {
                    r[ 'roots' ].forEach( x => glyphs( x, base, w, h ) );
                }
            } catch ( e ) {
                show( param.stack
                    ? { base: base, stride: stride, '!': e.stack.replaceAll( '\n', '<br/>' ) }
                    : { base: base, stride: stride, '!': e } );
            }
        }

        function allRoots( base, w, h, param = {} ) {
            aoi( base )
                // drop strides 0, 1
               .splice( 2 )
               .forEach( stride => oneRoots( base, stride, w, h, param ) );
        }


        function plot( points, param = {} ) {
            const { css = [] } = param;

            const x3dRoot = reify(
                "x3d",
                { "width": "100%", "height": "100%" },
                [
                    reify(
                        "scene",
                        { "id": "plot_scene_root" },
                        points.map( p => p.shape )
                    )
                ]
            );

            const sourceId = 'calculationScript';
            const sourceElement = document.getElementById( sourceId );

            if ( !css.includes( 'rightFlow' ) ) {
                css.push( 'leftFlow' );
            }


            const runButton = reify(
                "input",
                { "type": "button", "value": "run" },
                []
            );
            runButton.disabled = false;
            runButtonAction = ( iteration ) => {
                if ( iteration == 0 ) {
                    runButton.disabled = false;
                    runButton.value = 'forces';
                } else {
                    if ( !runButton.disabled ) {
                        runButton.disabled = false;
                    }
                    runButton.value = iteration;
                };
            };
            runButton.onclick = () => applyForces( points, param, runButtonAction );

            sourceElement
                .parentNode
                .appendChild(
                    reify(
                        "div",
                        { "class": [ 'scriptPanelResult', ...css ].join( "," ) },
                        [ runButton, x3dRoot ] ) );

            x3dom.reload();

            points.forEach( p => {
                new x3dom.Moveable(
                    x3dRoot,
                    p.shape,
                    ( shape, position ) => {
                         p.coord = [ position.x, position.y, position.z ];
                         p.moveLinks();
                    },
                    0 );
            } );

            applyForces( points, param, runButtonAction );
        }
    </script>




    <style>
        .scriptPanel {
            width: 100%;
        }
        .scriptPanelResult {
            margin: 10px;
        }
        .scriptPanelTextArea {
            width: 100%;
            white-space: pre;
            overflow-wrap: normal;
            overflow-x: scroll;
        }
        .symbol-details { font-size: 90%; border-top: solid 1px black; border-bottom: solid 1px black }
        .symbol-details tr { vertical-align: top; }
        .symbol-details tr:nth-child(even) { background: Ivory; }
        .symbol-details tr:nth-child(odd) { background: WhiteSmoke; }
        .symbol-details tr > td { border-top: 1px black dotted; }

        .resizable {
            overflow-wrap: normal;
            overflow-x: scroll;
        }
        .leftFlow {
           float: left;
        }
        .rightFlow {
           float: right;
        }

    </style>

</head>
<body onload="calculateNow()">
    <input type="button" value="eval" onclick="calculateNow()"/>
    <input type="button" value="clear" onclick="clearResults()"/>
    <label class="summaryLeft">clear on calculate<input type="checkbox" checked="checked" id="clearOnCalculate"/></label>
    <br/>
    <textarea id="calculationScript" class="scriptPanel" rows="6">const orb = new Orbitation( [ 2, 2, 2, 5 ] );
const param = {
    forces: [ 'origin', 'link', 'pair' ],
    originFactor: -0.001,
    pairFactor: 0.001,
    minDist: 0.0001,
    minDelta: 0.00000001,
    maxDelta: 5,
    rods: {
        '-1': [ 100, -0.01 ],
        '2': [  5 , 1 ],
        '3': [  1, 2 ]
    }
};
plot( orb.x3domGroup(), { css: [ 'resizable' ], iterations: 5000, tickTime: 2, ...param } );
show( orb.symbolsTable(), { css: [ 'rightFlow' ] } );
pagebreak();
show( orb.fragmentsBlock() );
show( orb.htmlTable() );
</textarea>
</body>
</html>