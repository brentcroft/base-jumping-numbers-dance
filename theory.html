<html>
    <head>
        <meta charset="utf-8"/>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script>
            MathJax = {
              tex: {
                tags: 'ams'
              }
            };
        </script>
        <style>
            body {
                font-family: Arial, Helvetica, sans-serif;
                width: 80%;
                font-size: 80%;
                padding: 20pt;
            }

            .small {
                font: italic 40% sans-serif;
            }

            .selected { background: Pink; }

            th { padding-left: 2pt; padding-right: 2pt; }

            .sort-asc::after { content: " \2193"; font-face: bold; }
            .sort-desc::after { content: " \2191"; font-face: bold;  }

            td.sum-total { text-align: center; }
            span.sum-total { border-top: 1px solid;}

            .chain-details { font-size: 80%; }
            .chain-details tr { vertical-align: top; }
            .chain-details tr:nth-child(even) { background: Ivory; }
            .chain-details tr:nth-child(odd) { background: WhiteSmoke; }

            .pagebreak {
                min-height: 1px;
                page-break-before: always;
            }

            .equation-list { list-style-type: none; }
            .equation-list li { padding: 6pt; }

            input[type=number]{
                width: 40pt;
                text-align: right;
            }
        </style>
        <script src="js/chains.js"></script>
        <script src="js/factors.js"></script>
        <script src="js/svg.js"></script>
        <script src="js/ui.js"></script>
        <script>
            function toggleSelected( source, clear = false ) {

                var tableNode = source.parentNode;
                while ( tableNode && tableNode.tagName != "TABLE" ) {
                    tableNode = tableNode.parentNode;
                }

                var selector = `#${ tableNode.getAttribute( "id" ) } td.selected`;

                var selectedItems  = document
                    .querySelectorAll( selector );

                if (selectedItems ) {
                    selectedItems
                        .forEach( ( selectedItem ) => selectedItem.classList.remove( "selected" ) );
                }

                if ( !clear ) {
                    source.classList.add( "selected" );
                }
            }

            function drawChainOnGrid( gridId, chainSystem, chain = [ [ 0, 0 ] ], source ) {
                removeChainsFromGrid( gridId );
                drawGridChain( gridId, chain, chainSystem );

                if ( source ) {
                    toggleSelected( source );
                }
            }

            function drawChainsOnGrid( gridId, chainSystem, chains = [ [ [ 0, 0 ] ] ], source ) {
                removeChainsFromGrid( gridId );
                for ( var i = 0; i < chains.length; i++ ) {
                    drawGridChain( gridId, chains[ i ], chainSystem, getColor( 10, i ) );
                }

                if ( source ) {
                    toggleSelected( source, true );
                }
            }

            function drawChainSystemOnGrid( gridId, chainSystem, source ) {
                removeChainsFromGrid( gridId );
                var chains = chainSystem.chains;
                for ( var i = 0; i < chains.length; i++ ) {
                    var chain = chains[ i ].coordsArray();
                    drawGridChain( gridId, chain, chainSystem, getColor( 10, i ) );
                }

                if ( source ) {
                    toggleSelected( source, true );
                }
            }

            function removeChainsFromGrid( gridId ) {
                removeGridChains( gridId );
            }


            function drawRandomChains( gridId, tableId, chainSystem ){

                randomChainSystem = getRandomChainSystem( chainSystem );

                var cellClick = `drawChainOnGrid( '${ gridId }', randomChainSystem, arrayFromChainText( this ), this )`;
                var totalClick = `drawChainSystemOnGrid( '${ gridId }', getChainSystem( ${ chainSystem.base }, ${ chainSystem.mult } ), this )`;

                drawChainSystemOnGrid( gridId, randomChainSystem );
                drawChainSystemTable( tableId, randomChainSystem, cellClick, totalClick );
            }

            function drawHarmonicChains( gridId, tableId, chainSystem ){

                var cellClick = `drawChainOnGrid( '${ gridId }', getChainSystem( ${ chainSystem.base }, ${ chainSystem.mult } ), arrayFromChainText( this ), this )`;
                var totalClick = `drawChainSystemOnGrid( '${ gridId }', getChainSystem( ${ chainSystem.base }, ${ chainSystem.mult } ), this )`;

                drawChainSystemOnGrid( gridId, chainSystem );
                drawChainSystemTable( tableId, chainSystem, cellClick, totalClick );
            }

            function pageInit(){
                initCurrentChainSystem( true );
            }

            function initCurrentChainSystem( randomSystem = false ) {

                chainSystem = getCurrentChainSystem();

                var width = 600;
                var height = 120

                chainSystem.scale = [ height / chainSystem.mult, width / chainSystem.base ];
                chainSystem.origin = [ 0, 0 ];


                drawGrid( "default_cs_grid", chainSystem );

                if ( randomSystem ) {
                    drawRandomChains( "default_cs_grid", "default_cs_table", chainSystem );
                } else {
                    drawHarmonicChains( "default_cs_grid", "default_cs_table", chainSystem);
                }
            }
        </script>
    </head>
    <body onload="pageInit()">
        <div>
            <h1>Jumping Bases: Numbers Dance</h1>

            Any two natural numbers greater than one, let's say \(b, m > 1\),
            entirely specify the points of a two dimensional grid
            as the set of coordinates \( (i, j) \),
            where \(  0 \le i < m \) and \( 0 \le j < b \).
            <br/><br/>
            For example,
            with \( b \) = <input id="base" name="base" type="number" size="4" min="2" max="20" value="10" onchange="initCurrentChainSystem()" ondblclick="initCurrentChainSystem()"/>,
            \( m \) = <input id="mult" name="mult" type="number" size="4" min="2" max="20" value="4" onchange="initCurrentChainSystem()" ondblclick="initCurrentChainSystem()"/>,
            the grid coordinates \( (i, j) \) are:

            <svg id="default_cs_grid" viewBox="-10 -10 610 130" xmlns="http://www.w3.org/2000/svg"></svg>

            A circular path
            through one or more points on a grid
            makes a chain,
            a non-empty sequence of distinct grid coordinates,
            where twisting the chain "left" or "right",
            by moving a coordinate from one end of a sequence to the other makes no difference to the chain.
            <br/>
            <br/>

            A chain system is a set of distinct chains spanning the grid coordinates specified by some \(b, m > 1\),
            so that each coordinate appears once and in one chain only.
            <br/>
            <br/>
            A chain system is harmonic, with fundamental \( p \) being the length of the longest chain,
            if the length of every chain is a simple factor of the fundamental \( p \),
            and every chain has a coordinate sum in proportion to \( ( m-1, b-1 ) \).
            <br/>
            <br/>

            <a href="javascript: drawRandomChains( 'default_cs_grid', 'default_cs_table', chainSystem )">Random</a> |
            <a href="javascript: drawHarmonicChains( 'default_cs_grid', 'default_cs_table', chainSystem )">Harmonic</a>
            <br/>
            <br/>
            <div id="default_cs_table"></div>

            <br/>


            <h3>Executive Summary</h3>

            For any choice of two natural numbers greater than unity, say \( b, m > 1 \),
            there is a harmonic chain system orchestrated by three natural numbers: \( p, C, D \),
            where \( p \) is the fundamental,
            such that:

            \begin{matrix}
                p < (mb - 1), & C = \frac { m^{p} - 1 } { (mb - 1)}, & D = \frac { b^{p} - 1 } { (mb - 1)}
            \end{matrix}

            Play:
                <a href="http://brentcroft.com/jumping-bases-numbers-dance">Chain System Workshop</a>

            <br/>
            <br/>

            <hr class="pagebreak"/>
            <!--




            -->
            <h2>Base Jumping</h2>


            Grid point coordinates can be mapped
            to a single contiguous dimension
            in the range from \( 0 \) to \( bm - 1 \)
            by two distinct functions:
            <ol class="equation-list">
                <li>
                    \( id(i, j) \to bi + j \)
                    <br/>
                    <sub>Calculate the arguments as a number in base b.</sub>
                    </li>
                <li>
                    \( di(i, j) \to mj + i \)
                    <br/>
                    <sub>Calculate the arguments <b>in reverse</b> as a number in base m.</sub></li>
            </ol>

            With these two functions, for any \(b, m > 1\), we can create two arrays of coordinates, \( idx \) and \( dix \), each of length \( bm \).
            <ul>
                <li>Each coordinate is indexed: by \( id( i, j ) \) in \( idx \), and by \( di( i, j ) \) in \( dix \).</li>
                <li>They both do the same job, either will suffice to tally off, or serialize, all the grid coordinates within a single iteration.
                <br/>
                    They just follow different routes to span the grid coordinates.</li>
            </ul>
            For example, in javascript, for some \(b, m \), we might have:
            <pre>
    const id = ( i, j ) => ( b * i ) + j;
    const di = ( i, j ) => ( m * j ) + i;

    const idx = [];
    const dix = [];

    for ( var i = 0; i < m; i++) {
        for ( var j = 0; j < b; j++) {

            const gridPoint = {
                coord: [ i, j ],
                id: id( i, j ),
                di: di( i, j )
            };

            idx[ gridPoint.id ] = gridPoint;
            dix[ gridPoint.di ] = gridPoint;
        }
    }
            </pre>
            Both \( idx \) and \( dix \) each implement an inverse of their respective generating function by returning the coordinate at each index value.
            <ul class="equation-list">
                <li>
                    \( id^{-1}( bi + j ) \to ( i, j ) \)
                    <br/>
                    <sub>Lookup the argument (i.e. the value of \( bi + j ) \) in \( idx \).</sub>
                </li>
                <li>
                    \( di^{-1}( mj + i ) \to (i, j) \)
                    <br/>
                    <sub>Lookup the argument (i.e. the value of \( mj + i ) \) in \( dix \).</sub>
                </li>
            </ul>
            By using an index we avoid doing any division or subtraction
            even though a coordinate can be calculated from an index value using \( \operatorname{div} \) and \( \bmod \),
            for example:
            <ul class="equation-list">
                <li>\( id_{-1}( k ) \to ( k \operatorname{div} b, k \bmod b ) \)</li>
                <li>\( di_{-1}( k ) \to ( k \bmod m, k \operatorname{div} m ) \)</li>
            </ul>

            <hr class="pagebreak"/>
            <!--



            -->
            <h3>Index Weaving</h3>

            Specifically, calculating the position of a coordinate in \( dix \)
            and then using the result to select a coordinate from \( idx \),
            thereby introducing a \( twist \):
            <ul class="equation-list">
                <li>\( twist( i, j ) = id^{-1}( di( i, j ) ) \)</li>
            </ul>

            Intuitively:
            <ul class="equation-list">
                <li>Applying \( twist \) to any coordinate must either return the same coordinate,
                    or jump to another coordinate in the grid.</li>
                <li>Applying \( twist \) successively,
                    starting from any coordinate,
                    and for each coordinate encountered,
                    must eventually, or immediately,
                    return to the starting coordinate.
                    <br/>
                    <sub>
                        \( twist \) has an inverse \( twist^{-1} \), that jumps between coordinates in reverse.
                        Starting from any coordinate, eventually (or immediately) \( twist \) and \( twist^{-1} \) must meet,
                        there's only a limited number of grid coordinates available.
                        Each coordinate in the grid has two ways in which to jump, there can't be a one-way coordinate.
                        (Complementary Ouroboroi - not quite intuitive)
                    </sub>
                </li>
            </ul>

            Repeated application of \( twist \) must group the coordinates into looping chains, where either:
            <ul>
                <li>
                    a chain contains more than one coordinate
                    and can be rotated in either direction by applying \( twist \) or \( twist^{-1} \).
                </li>
                <li>
                    a chain contains one coordinate, a singleton loop on it's own,
                    and can be rotated in either direction,
                    immediately back to itself,
                    by applying \( twist \) or \( twist^{-1} \).
                </li>
            </ul>
            <!--



            -->
            By inspection, for any choice of \( b \) and \( m \),
            there are always at least two singleton chains
            and at least one non-singleton chain with \( ( 0, 1 ) \) and \( ( 1, 0 ) \) adjacent,
            since:
            <ul class="equation-list">
                <li>
                    \( twist( 0, 0 ) = ( 0, 0 ) \)
                </li>
                <li>
                    \( twist( m-1, b-1 ) = ( m-1, b-1 ) \)
                </li>
                <li>
                    \( twist( 1, 0 ) = ( 0, 1 ) \)
                </li>
            </ul>
            We can find all the chains, given a choice of \( b \) and \( m \), by iterating over one index, and tallying off with the other.
            For example, continuing the previous javascript example, we might have:
            <pre>
    const chains = [];

    for ( var i = 0; i < ( b * m ); i++) {

        if ( dix[ i ] == -1 ) {
            continue;
        }

        dix[ i ] = -1;

        var gridPoint = idx[ i ];

        const chain = {
            index: i,
            coords: [ gridPoint ]
        };

        while ( gridPoint.di != i ) {
            dix[ gridPoint.di ] = -1;
            gridPoint = idx[ gridPoint.di ];
            chain.coords.push( gridPoint );
        }

        chains[ chains.length ] = chain;
    }
            </pre>

            With a bit more code, we can generate tables and plot chains on grids.
            <br/>

            <hr class="pagebreak"/>

            <h2>Sample Chain Systems</h2>

            <svg id="sample_cs_b_2_m_2_grid" viewBox="-10 -10 610 70" xmlns="http://www.w3.org/2000/svg"></svg>
            <div id="sample_cs_b_2_m_2_table"></div>
            <script>
                var sample_cs_b_2_m_2 = getChainSystem( 2, 2 );

                var width = 400;
                var height = 60

                sample_cs_b_2_m_2.scale = [ height / sample_cs_b_2_m_2.mult, width / sample_cs_b_2_m_2.base ];
                sample_cs_b_2_m_2.origin = [ 0, 0 ];

                drawGrid( "sample_cs_b_2_m_2_grid", sample_cs_b_2_m_2 );
                drawHarmonicChains( "sample_cs_b_2_m_2_grid", "sample_cs_b_2_m_2_table", sample_cs_b_2_m_2 );
            </script>

            <br/>

            <svg id="sample_cs_b_10_m_2_grid" viewBox="-10 -10 610 70" xmlns="http://www.w3.org/2000/svg"></svg>
            <div id="sample_cs_b_10_m_2_table"></div>
            <script>
                var sample_cs_b_10_m_2 = getChainSystem( 10, 2 );

                var width = 400;
                var height = 60

                sample_cs_b_10_m_2.scale = [ height / sample_cs_b_10_m_2.mult, width / sample_cs_b_10_m_2.base ];
                sample_cs_b_10_m_2.origin = [ 0, 0 ];

                drawGrid( "sample_cs_b_10_m_2_grid", sample_cs_b_10_m_2 );
                drawHarmonicChains( "sample_cs_b_10_m_2_grid", "sample_cs_b_10_m_2_table", sample_cs_b_10_m_2 );
            </script>

            <br/>

            With \( b = 10, m = 2\), there are only three chains, and the longest chain, with \( ( 0, 1 ) \) and \( ( 1, 0 ) \) adjacent, has length 18:
            <br/>
            <br/>

            Interestingly:
            <ul class="equation-list">
                <li>\( \frac { ( 10^{18} - 1 ) } { 19 } = 52631578947368421_{base 10} = (3^{3} . 7 . 73 ) \)
                    <br/>
                    <sub>
                        Note that reading just the "j" digit, from each coordinate in the chain containing \( ( 0, 1 ) \), backwards, produces "052631578947368421".
                    </sub>
                </li>
                <li>
                    \( \frac { ( 2^{18} - 1 ) } { 19 } = 13797_{base 10} = (2^{5} . 173 . 184199 . 51613469 ) \)
                    <br/>
                    <sub>
                        Note that reading just the "i" digit, from each coordinate in the chain containing \( ( 0, 1 ) \), forwards, produces "000011010111100101"
                        which read as a base 2 number is 13797 in base 10.
                    </sub>
                </li>
            </ul>




        </div>
        <hr class="pagebreak"/>
        <h2>Chain System Algebra</h2>

        A circular system of \( p \) independent equations,
        where \( p < (mb - 1) \),
        can be constructed starting from any coordinate \((i_0, j_0)\)
        and applying \( twist \) successively \( p \) times
        until the starting coordinate recurs,
        i.e. \( (i_0, j_0) = (i_p, j_p) \):
        <br/>

        \begin{align*}
        bi_1+j_1 &= i_{0}+mj_{0}\\
        bi_2+j_2 &= i_{1}+mj_{1}\\
        & ... \\
        bi_{p-1}+j_{p-1} &= i_{p-2}+mj_{p-2}\\
        bi_0+j_0 &= i_{p-1}+mj_{p-1}
        \end{align*}
        <br/>

        <hr/>
        <div>
            The sum of coordinate digits in each chain is in constant proportion:

            \begin{align}
            \sum_{k=0}^{p-1} i_k(b-1)& = \sum_{k=0}^{p-1} j_k(m-1) \\
            \end{align}
            <br/>
        </div>
        <hr/>

        <div>
            Construct identity ladder resolving for j:
            <br/><br/>

            \begin{align*}
            j_1 &= i_0 - bi_1 + mj_0 \\
            j_2 &= i_1 - bi_2 + mj_1 \\
            j_3 &= i_2 - bi_3 + mj_2 \\
            j_4 &= i_3 - bi_4 + mj_3 \\
            &... \\
            j_{p-1} &= i_{p-2} - bi_{p-1} + mj_{p-2} \\
            j_0 &= i_{p-1} - bi_0 + mj_{p-1}
            \end{align*}
        </div>
        <hr class="pagebreak"/>
        <div>
            Build out 1:
            <br/><br/>

            \begin{align*}
            j_1 &= i_{0} - bi_1 + mj_{0} \\
            \end{align*}

            <br/><br/>
        </div>
        <div>
            Build out 2:
            <br/><br/>

            \begin{align*}
            j_2 &= i_1 - bi_2 + mj_1 \\
            j_2 &= i_1 - bi_2 + m(i_0 - bi_1 + mj_0) \\
            j_2 &= i_1 - bi_2 + mi_0 - mbi_1 + m^2j_0 \\
            j_2 &= (1-mb)i_1 - bi_2 + mi_0 + m^2j_0
            \end{align*}

            <br/><br/>
        </div>
        <div>
            Build out 3:
            <br/><br/>

            \begin{align*}
            j_3 &= i_2 - bi_3 + mj_2 \\
            j_3 &= i_2 - bi_3 + m((1-mb)i_1 - bi_2 + mi_0 + m^2j_0) \\
            j_3 &= i_2 - bi_3 + m(1-mb)i_1 - mbi_2 + m^2i_0 + m^3j_0 \\
            j_3 &= (1-mb)i_2 + m(1-mb)i_1 - bi_3 + m^2i_0 + m^3j_0
            \end{align*}

            <br/><br/>
        </div>
        <div>
            Build out 4:
            <br/><br/>

            \begin{align*}
            j_4 &= i_3 - bi_4 + mj_3 \\
            j_4 &= i_3 - bi_4 + m((1-mb)i_2 + m(1-mb)i_1 - bi_3 + m^2i_0 + m^3j_0) \\
            j_4 &= i_3 - bi_4 + m(1-mb)i_2 + m^2(1-mb)i_1 - mbi_3 + m^3i_0 + m^4j_0 \\
            j_4 &= (1-mb)i_3  + m(1-mb)i_2 + m^2(1-mb)i_1 -bi_4 + m^3i_0 + m^4j_0
            \end{align*}

            <br/><br/>
        </div>
        <div>
            Build out 5:
            <br/><br/>

            \begin{align*}
            j_5 &= i_4 - bi_5 + mj_4 \\
            j_5 &= i_4 - bi_5 + m((1-mb)i_3  + m(1-mb)i_2 + m^2(1-mb)i_1 - bi_4 + m^3i_0 + m^4j_0) \\
            j_5 &= i_4 - bi_5 + m(1-mb)i_3  + m^2(1-mb)i_2 + m^3(1-mb)i_1 - mbi_4 + m^4i_0 + m^5j_0) \\
            j_5 &= (1 - mb)i_4 + m(1-mb)i_3  + m^2(1-mb)i_2 + m^3(1-mb)i_1 - bi_5 + m^4i_0 + m^5j_0) \\
            j_5 &= (1 - mb)\sum_{k=0}^{5-2} m^{5-k-1}i_k - bi_5 + m^4i_0 + m^5j_0 \\
            \end{align*}

            <br/><br/>
        </div>
        <hr class="pagebreak"/>
        <div>
            Generalize for <code>n</code>:

            \begin{align*}
            j_n &= (1-mb)\sum_{k=0}^{n-2} m^{n-k-1}i_k - bi_n + m^{n-1}i_0 + m^nj_0 \\
            j_n &= (1-mb)\sum_{k=0}^{n-2} m^{n-k-1}i_k - bi_n + m^{n-1}i_0 + m^n(i_{n-1} - bi_0 + mj_{n-1}) \\
            j_n &= (1-mb)\sum_{k=0}^{n-2} m^{n-k-1}i_k - bi_n + m^{n-1}i_0 + m^ni_{n-1} - m^nbi_0 + m^{n+1}j_{n-1} \\
            j_n &= (1-mb)\sum_{k=0}^{n-2} m^{n-k-1}i_k - bi_n + m^{n-1}(1 - mb)i_0 + m^n(i_{n-1} + mj_{n-1}) \\
            j_n &= (1-mb)(\sum_{k=0}^{n-2} m^{n-k-1}i_k + m^{n-1}i_0) - bi_n + m^n(i_{n-1} + mj_{n-1}) \\
            j_n &= (1-mb)\sum_{k=0}^{n-1} m^{n-k-1}i_k - bi_n + m^n(i_{n-1} + mj_{n-1}) \\
            \end{align*}
        </div>
        <hr/>
        <div>
            Re-assemble:

            \begin{align*}
            (mb-1)\sum_{k=0}^{n-1} m^{n-k-1}i_k &= m^n(i_{n-1} + mj_{n-1}) - (bi_n + j_n) \\
            \end{align*}
            \begin{align}
            \sum_{k=0}^{n-1} m^{n-k-1}i_k &= { m^n(i_{n-1} + mj_{n-1}) - (bi_n + j_n) \over (mb-1) }
            \end{align}
        </div>
        <hr/>
        <div>
            Let <code>n = p</code>,
            and then substitute
            for <code>i<sub>p-1</sub> + mj<sub>p-1</sub></code>
            and <code>bi<sub>p</sub> + j<sub>p</sub></code>:

            \begin{align*}
            \sum_{k=0}^{p-1} m^{p-k-1}i_k &= { m^p(i_{p-1} + mj_{p-1}) - (bi_p + j_p) \over (mb-1) } \\
            \sum_{k=0}^{p-1} m^{p-k-1}i_k &= { m^p(bi_0 + j_0) - (bi_0 + j_0) \over (mb-1) } \\
            \end{align*}
        </div>
        <hr/>
        <div>
            Since the choice of <code>(i<sub>0</sub>, j<sub>0</sub>)</code> is arbitrary,
            this is true for any choice:

            \begin{align}
            \sum_{k=0}^{p-1} m^{p-k-1}i_k &= (bi_0 + j_0){ (m^p - 1) \over (mb-1) } \\
            \end{align}

            By symmetry:
            \begin{align}
            \sum_{k=0}^{p-1} b^{p-k-1}i_k &= (mj_0 + i_0){ (b^p - 1) \over (mb-1) } \\
            \end{align}
        </div>
        <hr class="pagebreak"/>
        <div>
            Identify two characteristic constants:
            \begin{align}
            C &= { (m^p - 1) \over (mb-1) },& D &= { (b^p - 1) \over (mb-1) } \\
            \end{align}

            <br/>

            <b>Rotation right:</b>
            choose any <code>(i, j)</code>,
            follow the chain for <code>p</code> steps,
            collect the <code>i</code> values in sequence.<br/>

            <br/>

            \begin{align}
            \sum_{k=0}^{p-1} m^{p-k-1}i_k &= (bi + j)C \\
            \end{align}

            <br/>

            <b>Rotation left:</b>
            choose any <code>(i, j)</code>,
            follow the chain in reverse for <code>p</code> steps,
            collect the <code>j</code> values in sequence.<br/>

            <br/>

            \begin{align}
            \sum_{k=0}^{p-1} b^kj_{p-k-1} &= (i + mj)D \\
            \end{align}
        </div>
        <hr/>
        <div>
            For all b,m the chain from <code>(0,1)</code> has:

            \begin{align*}
                i_0 &= 0,& j_0 &= 1 \\
                i_{p-1} &= 1,& j_{p-1} &= 0 \\
            \end{align*}

            The sequence of <code>i</code> values, from (0,1), interpreted as a number in base <code>m</code>
            is equal to <code>C</code>.

            \begin{align}
            1 + \sum_{k=1}^{p-2} m^{p-k-2}i_k &= { m^p - 1 \over mb - 1 } &= C \\
            \end{align}
            <br/>

            The sequence of <code>j</code> values, in reverse from (1,0), interpreted as a number in base <code>b</code>
            is equal to <code>D</code>:

            \begin{align}
            1 + \sum_{k=1}^{p-2} b^{k-1}j_{p-k-2} &= { b^p - 1 \over mb - 1 } &= D \\
            \end{align}
        </div>
        <hr/>
        <div>
            For all b & m, chain <code>(m-1,b-1)</code>, as expected, has:

            \begin{align*}
            i &= m-1  \\
            j &= b-1 \\
            \sum_{k=0}^{p-1} m^k(m-1) &= (mb - 1 )C \\
            \sum_{k=0}^{p-1} m^k(m-1) &= m^p - 1 \\
            \end{align*}
        </div>

    </body>
</html>
