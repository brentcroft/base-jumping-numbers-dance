<html>
    <head>
        <meta charset="utf-8"/>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <!--
        <script
                id="MathJax-script"
                type="text/javascript"
                async
                src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
                -->
        <script
                id="MathJax-script"
                type="text/javascript"
                async
                src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML">
        </script>

        <script>
            MathJax = {
              tex: {
                tags: 'ams'
              }
            };
        </script>
        <style>
            body {
                font-family: Arial, Helvetica, sans-serif;
                width: 80%;
                font-size: 80%;
                padding: 20pt;
            }

            iframe {
              resize: both;
              width: 100%;
              height: 200px;
              overflow: auto;
            }

            .small {
                font: italic 40% sans-serif;
            }

            th {
                vertical-align: bottom;
            }

            .chain-details-legend {
                text-align: center;
                font-style: italic;
            }

            .grid-controls-container {
                width: 100%;
                text-align: right;
                font-size: 90%;
            }

            .grid-controls {
                display: inline;
            }
            .control {
                display: inline;
            }

            .resizable {
                resize: both;
                overflow: auto;
            }

            .legend {
                text-align: center;
                font-style: italic;
            }

            .selected { background: Pink; }

            th { padding-left: 2pt; padding-right: 2pt; }

            .sort-asc::after { content: " \2193"; font-face: bold; }
            .sort-desc::after { content: " \2191"; font-face: bold;  }

            td.sum-total { text-align: center; }
            span.sum-total { border-top: 1px solid;}

            .chain-details { width: 100%; font-size: 80%; }
            .chain-details tr { vertical-align: top; }
            .chain-details tr:nth-child(even) { background: Ivory; }
            .chain-details tr:nth-child(odd) { background: WhiteSmoke; }

            .pagebreak {
                min-height: 1px;
                page-break-before: always;
            }

            .equation-list { list-style-type: none; }
            .equation-list li { padding: 6pt; }

            input[type=number] {
                width: 40pt;
                text-align: right;
            }
        </style>
        <script src="js/chains.js"></script>
        <script src="js/factors.js"></script>
        <script src="js/svg.js"></script>

        <script src="js/ui.js"></script>
        <script>
            const queryString = window.location.search;
            const urlParams = new URLSearchParams(queryString);

            var base = urlParams.has('base') ? Number( urlParams.get('base') ) : 13;
            var mult = urlParams.has('mult') ? Number( urlParams.get('mult') ) : 4;

            function swapBases() {
                const baseElement = document.getElementById("base");
                const multElement = document.getElementById("mult");

                const baseValue = baseElement.value;
                const multValue = multElement.value;

                baseElement.value = multValue;
                multElement.value = baseValue;

                initCurrentChainSystem();
            }

            function toggleSelected( source, clear = false ) {

                var tableNode = source.parentNode;
                while ( tableNode && tableNode.tagName != "TABLE" ) {
                    tableNode = tableNode.parentNode;
                }

                var selector = `#${ tableNode.getAttribute( "id" ) } td.selected`;

                var selectedItems  = document
                    .querySelectorAll( selector );

                if (selectedItems ) {
                    selectedItems
                        .forEach( ( selectedItem ) => selectedItem.classList.remove( "selected" ) );
                }

                if ( !clear ) {
                    source.classList.add( "selected" );
                }
            }


            function drawChainOnGrid( id, chainSystem, chain = [ [ 0, 0 ] ], source, color = "rgba( 255, 0, 0, 1 )", cssClass = "chain" ) {
                removeGridChains( id, cssClass );
                drawGridChain( id, chain, chainSystem, color, cssClass );
                drawGridChainCentre( id, chain, chainSystem, color, cssClass );

                if ( source ) {
                    toggleSelected( source );
                }
            }

            function drawPathOnGrid( id, chainSystem, path = [ [ 0, 0 ] ], source, color = "rgba( 255, 0, 0, 1 )", cssClass = "chain" ) {
                drawGridPath( id, path, chainSystem, color, cssClass );
            }


            function drawChainsOnGrid( id, chainSystem, chains = [ [ [ 0, 0 ] ] ], source ) {
                removeGridChains( id );
                for ( var i = 0; i < chains.length; i++ ) {
                    drawGridChain( id, chains[ i ], chainSystem, getColor( 10, i ) );
                }

                if ( source ) {
                    toggleSelected( source, true );
                }
            }

            function drawChainSystemOnGrid( id, chainSystem, source ) {

                removeGridChains( id );

                var chains = chainSystem.chains;
                for ( var i = 0; i < chains.length; i++ ) {
                    var chain = chains[ i ].coordsArray();
                    drawGridChain( id, chain, chainSystem, getColor( 10, i ) );
                }

                if ( source ) {
                    toggleSelected( source, true );
                }
            }

            function drawRandomChains( id, chainSystem, drawAllChains = false, drawX3Dom = true ) {

                randomChainSystem = getRandomSystem( chainSystem );

                var cellClick = `drawChainOnGrid( '${ id }', randomChainSystem, arrayFromChainText( this ), this )`;
                var totalClick = `drawChainSystemOnGrid( '${ id }', randomChainSystem, this )`;

                drawChainSystemTable( id, randomChainSystem, cellClick, totalClick );

                if ( drawAllChains ) {
                    drawChainSystemOnGrid( id, randomChainSystem );
                } else {
                    drawChainOnGrid( id, randomChainSystem, randomChainSystem.chains[1].coordsArray() );
                }

                if ( drawX3Dom ) {
                    openX3DomViewer( id, randomChainSystem );
                }
            }

            function drawHarmonicChains( id, chainSystem, drawAllChains = false, drawX3Dom = true ) {

                var cellClick = `drawChainOnGrid( '${ id }', getChainSystem( ${ chainSystem.base }, ${ chainSystem.mult } ), arrayFromChainText( this ), this )`;
                var totalClick = `drawChainSystemOnGrid( '${ id }', getChainSystem( ${ chainSystem.base }, ${ chainSystem.mult } ), this )`;

                drawChainSystemTable( id, chainSystem, cellClick, totalClick );

                if ( drawAllChains ) {
                    drawChainSystemOnGrid( id, chainSystem );
                } else {
                    drawChainOnGrid( id, chainSystem, chainSystem.chains[1].coordsArray() );
                }

                if ( drawX3Dom ) {
                    openX3DomViewer( chainSystem );
                }
            }

            function pageInit(){
                initCurrentChainSystem( null, false );
            }

            function initCurrentChainSystem( source = null, randomSystem = false ) {

                if ( source ) {
                    const isActive = ( source === document.activeElement );
                    if ( ! isActive) {
                        return;
                    }
                }

                const containerId = "default_cs";

                chainSystem = getCurrentChainSystem();

                setChainSystemSvg( containerId, chainSystem, dimensions = [ 600, 150 ], oversize = [ 1, 1 ], origin = [ 0, 0 ] );

                writeChainSystemBlock( containerId, chainSystem, false, true, true );

                if ( randomSystem ) {
                    drawRandomChains( containerId, chainSystem );
                } else {
                    drawHarmonicChains( containerId, chainSystem);
                }
            }

            function openX3DomViewer( chainSystem ) {
                const containerId = "default_cs";
                const viewerContainerId = containerId + "_plot";
                const viewerContainer = document.getElementById( viewerContainerId );
                if ( viewerContainer ) {
                    var frameId = containerId + "_plot_frame";
                    var iframeHtml = `<iframe id="${ frameId }" src="viewer.html?base=${ chainSystem.base }&amp;mult=${ chainSystem.mult }&amp;random=false"></iframe>`;
                    viewerContainer.innerHTML = iframeHtml;
                }
            }

        </script>
    </head>
    <body onload="pageInit()">
        <div>
            <h1>Jumping Bases Numbers Dance</h1>

            Two natural numbers greater than one, let's say \(b, m > 1\),
            define the points of a two dimensional grid
            as the set of coordinates \( (i, j) \),
            where \(  0 \le i < m \) and \( 0 \le j < b \).
            <br/><br/>
            For example,
            with \( b \) = <script>
                document.write( `<input id="base" name="base" type="number" size="4" min="2" max="20" value="${ base }" onchange="initCurrentChainSystem( this )" ondblclick="initCurrentChainSystem()"/>` );
            </script>,
            \( m \) = <script>
                document.write( `<input id="mult" name="mult" type="number" size="4" min="2" max="20" value="${ mult }" onchange="initCurrentChainSystem( this )" ondblclick="initCurrentChainSystem()"/>` );
            </script>,
            the grid coordinates \( (i, j) \) are:

            <div class="resizable" id="default_cs">

            </div>

            <div id="default_cs_plot_container">
                <div id="default_cs_plot"></div>
                <div class='legend'>
                    [ a, r, u | e, f, l, w, &lt;space&gt; ]
                    see: <a href="https://doc.x3dom.org/tutorials/animationInteraction/navigation/index.html" target="_new">x3dom navigation tutorial</a>
                    <br/><br/>
                </div>
            </div>

            A circular path through one or more points on a grid makes an orbit,
            a non-empty sequence of distinct grid coordinates where the ends join up.

            A grid has many possible sets of disjoint orbits
            that span the grid coordinates
            (each coordinate appears once and in one orbit only).
            <br/>
            <br/>
            However, every grid has a set of harmonic orbits
            with period \( p \) being the order (number of coordinates) of the longest orbit,
            where the order of every orbit is a simple factor of the period \( p \)
            and every orbit has a coordinate sum in proportion to \( ( m-1, b-1 ) \)
            (i.e. is centred on the diagonal \( [ ( 0, 0 ), ( m-1, b-1 ) ] \)).
            <br/>
            <br/>

<!--            <a href="javascript: openX3DomViewer( 'default_cs', chainSystem )">Viewer</a> |-->
            <a href="javascript: drawRandomChains( 'default_cs', chainSystem )">Random</a> |
            <a href="javascript: drawHarmonicChains( 'default_cs', chainSystem )">Harmonic</a>
            (<a href="javascript: swapBases()">swap</a> | <a href="javascript: riffle( 'default_cs_table_data', 'default_cs_table_riffler' )">riffle</a>)
            <br/>

            <br/>
            <div id="default_cs_table" class="resizable"></div>

            <br/>

            <h3>Executive Summary</h3>

            For any grid, say \( b, m > 1 \),
            there is an harmonic orbit system orchestrated by three natural numbers: \( p, C, D \),
            where \( p \) is the period,
            such that:

            \begin{matrix}
                p < (mb - 1), & C = \frac { m^{p} - 1 } { (mb - 1)}, & D = \frac { b^{p} - 1 } { (mb - 1)}
            \end{matrix}

            For every orbit (repeated by its harmonic to make \( p \)),
            the sequence of \( i \) values calculated as a number in base \( m \),
            starting at any element \( ( i, j ) \),
            and the reverse sequence of \( j \) values calculated in base \( b \) respectively are:

            \begin{align}
            \sum_{k=0}^{p-1} m^{p-k-1}i_k &= (bi + j)C \\
            \sum_{k=0}^{p-1} b^kj_{p-k-1} &= (i + mj)D
            \end{align}

            Therefore,
            \( C \) can be easily read in base \( m \) from the orbit containing \( ( 0, 1 )) \),
            and \( D \) can be easily read in base \( b \) from the same orbit in reverse starting at \( ( 1, 0 ) \).
            <br/>
            <br/>

            <div id="XXXdefault_cs_equation">

            </div>

            <hr class="pagebreak"/>
            <!--




            -->
            <h2>Base Jumping</h2>


            Grid coordinates can be indexed
            in the range from \( 0 \) to \( bm - 1 \)
            by two obvious functions:
            <ol class="equation-list">
                <li>
                    \( id(i, j) \to bi + j \)
                    <br/>
                    <sub>Calculate the arguments as a number in base b.</sub>
                    </li>
                <li>
                    \( di(i, j) \to mj + i \)
                    <br/>
                    <sub>Calculate the arguments <b>in reverse</b> as a number in base m.</sub></li>
            </ol>

            With these two functions, for any \(b, m > 1\), we can create two index arrays of coordinates, \( idx \) and \( dix \), each of length \( bm \).
            <ul>
                <li>Each coordinate is indexed: by \( id( i, j ) \) in \( idx \), and by \( di( i, j ) \) in \( dix \).
                    <br/>
                    <sub>They both do the same job, either will suffice to tally off, or serialize, all the grid coordinates within a single iteration.
                    <br/>
                        They just follow different routes to span the grid coordinates.</sub></li>
            </ul>

            For example, in javascript, for some \(b, m \), we might have:

            <pre>
    const id = ( i, j ) => ( b * i ) + j;
    const di = ( i, j ) => ( m * j ) + i;

    const idx = [];
    const dix = [];

    for ( var i = 0; i < m; i++) {
        for ( var j = 0; j < b; j++) {

            const gridPoint = {
                coord: [ i, j ],
                id: id( i, j ),
                di: di( i, j )
            };

            idx[ gridPoint.id ] = gridPoint;
            dix[ gridPoint.di ] = gridPoint;
        }
    }
            </pre>
            Both \( idx \) and \( dix \) each implement an inverse of their respective generating function by returning the coordinate at each index value.
            <ul class="equation-list">
                <li>
                    \( id^{-1}( bi + j ) \to ( i, j ) \)
                    <br/>
                    <sub>Lookup the argument (i.e. the value of \( bi + j ) \) in \( idx \).</sub>
                </li>
                <li>
                    \( di^{-1}( mj + i ) \to (i, j) \)
                    <br/>
                    <sub>Lookup the argument (i.e. the value of \( mj + i ) \) in \( dix \).</sub>
                </li>
            </ul>
            By using an index we avoid doing any division or subtraction
            even though a coordinate can be constructed from an index value, for an index, using \( \operatorname{div} \) and \( \bmod \).

            <hr class="pagebreak"/>
            <!--



            -->
            <h3>Index Weaving</h3>

            Specifically, using the position of a coordinate in \( dix \) to select a coordinate from \( idx \),
            thereby introducing a \( twist \):

            <ul class="equation-list">
                <li>\( twist( i, j ) = id^{-1}( di( i, j ) ) \)</li>
            </ul>

            Intuitively:
            <ul class="equation-list">
                <li>Applying \( twist \) to any coordinate must either return the same coordinate,
                    or jump to another coordinate in the grid.</li>
                <li>Applying \( twist \) successively,
                    starting from any coordinate,
                    and for each coordinate encountered,
                    must eventually, or immediately,
                    return to the starting coordinate.
                    <br/>
                    <sub>
                        \( twist \) has an inverse \( twist^{-1} \), that jumps between coordinates in reverse.
                        Starting from any coordinate, eventually (or immediately) \( twist \) and \( twist^{-1} \) must meet,
                        there's only a limited number of grid coordinates available.
                        Each coordinate in the grid has two ways in which to jump, there can't be a one-way coordinate.
                        (Complementary Ouroboroi - not quite intuitive)
                    </sub>
                </li>
            </ul>

            Repeated application of \( twist \) must out coordinates in a cycle, where either:
            <ul>
                <li>
                    a cycle contains more than one coordinate
                    and can be rotated in either direction by applying \( twist \) or \( twist^{-1} \).
                </li>
                <li>
                    a cycle contains only one coordinate, a fixed point,
                    and can be rotated in either direction,
                    immediately back to itself,
                    by applying \( twist \) or \( twist^{-1} \).
                </li>
            </ul>
            <!--



            -->
            By inspection, for any choice of \( b \) and \( m \),
            there are always at least two fixed point cycles
            and at least one non-fixed cycle with \( ( 0, 1 ) \) and \( ( 1, 0 ) \) adjacent,
            since:
            <ul class="equation-list">
                <li>
                    \( twist( 0, 0 ) = ( 0, 0 ) \)
                </li>
                <li>
                    \( twist( m-1, b-1 ) = ( m-1, b-1 ) \)
                </li>
                <li>
                    \( twist( 1, 0 ) = ( 0, 1 ) \)
                </li>
            </ul>
            We can find all the cycles, given a choice of \( b \) and \( m \), by iterating over one index, and tallying off with the other.
            For example, continuing the previous javascript example, we might have:
            <pre>
    const cycles = [];

    for ( var i = 0; i < ( b * m ); i++) {

        if ( dix[ i ] == -1 ) {
            continue;
        }

        dix[ i ] = -1;

        var gridPoint = idx[ i ];

        const cycle = {
            index: i,
            coords: [ gridPoint ]
        };

        while ( gridPoint.di != i ) {
            dix[ gridPoint.di ] = -1;
            gridPoint = idx[ gridPoint.di ];
            cycle.points.push( gridPoint );
        }

        cycles[ cycles.length ] = cycle;
    }
            </pre>

            With a bit more code, we can generate tables and plot cycles on grids.
            <br/>

            <hr class="pagebreak"/>

            <h2>Sample Cycle Systems</h2>

            <div id="sample_cs_b_2_m_2"></div>
            <script>
                var sample_cs_b_2_m_2 = getChainSystem( 2, 2 );

                setChainSystemSvg( "sample_cs_b_2_m_2", sample_cs_b_2_m_2, dimensions = [ 400, 60 ] );

                writeChainSystemBlock( "sample_cs_b_2_m_2", sample_cs_b_2_m_2, true, false, true );
                drawHarmonicChains( "sample_cs_b_2_m_2", sample_cs_b_2_m_2 );
            </script>

            <br/>

            <div id="sample_cs_b_10_m_2"></div>
            <script>
                var sample_cs_b_10_m_2 = getChainSystem( 10, 2 );

                setChainSystemSvg( "sample_cs_b_10_m_2", sample_cs_b_10_m_2, dimensions = [ 400, 60 ] );

                writeChainSystemBlock( "sample_cs_b_10_m_2", sample_cs_b_10_m_2, true, false, true );
                drawHarmonicChains( "sample_cs_b_10_m_2", sample_cs_b_10_m_2 );
            </script>

            <br/>

            With \( b = 10, m = 2\), there are only three cycles, and the longest cycle, with \( ( 0, 1 ) \) and \( ( 1, 0 ) \) adjacent, has length 18:
            <br/>
            <br/>

            Interestingly:
            <ul class="equation-list">
                <li>\( \frac { ( 10^{18} - 1 ) } { 19 } = 52631578947368421_{base 10} = (3^{3} . 7 . 73 ) \)
                    <br/>
                    <sub>
                        Note that reading just the "j" digit, from each coordinate in the chain containing \( ( 0, 1 ) \), backwards, produces "052631578947368421".
                    </sub>
                </li>
                <li>
                    \( \frac { ( 2^{18} - 1 ) } { 19 } = 13797_{base 10} = (2^{5} . 173 . 184199 . 51613469 ) \)
                    <br/>
                    <sub>
                        Note that reading just the "i" digit, from each coordinate in the chain containing \( ( 0, 1 ) \), forwards, produces "000011010111100101"
                        which read as a base 2 number is 13797 in base 10.
                    </sub>
                </li>
            </ul>




        </div>
        <hr class="pagebreak"/>
        <h2>Chain System Algebra</h2>

        A circular system of \( p \) independent equations,
        where \( p < (mb - 1) \),
        can be constructed starting from any coordinate \((i_0, j_0)\)
        and applying \( twist \) successively \( p \) times
        until the starting coordinate recurs,
        i.e. \( (i_0, j_0) = (i_p, j_p) \):
        <br/>

        \begin{align*}
        bi_1+j_1 &= i_{0}+mj_{0}\\
        bi_2+j_2 &= i_{1}+mj_{1}\\
        & ... \\
        bi_{p-1}+j_{p-1} &= i_{p-2}+mj_{p-2}\\
        bi_0+j_0 &= i_{p-1}+mj_{p-1}
        \end{align*}
        <br/>

        <hr/>
        <div>
            The sum of coordinate digits in each chain is in constant proportion:

            \begin{align}
            \sum_{k=0}^{p-1} i_k(b-1)& = \sum_{k=0}^{p-1} j_k(m-1) \\
            \end{align}
            <br/>
        </div>
        <hr/>

        <div>
            Construct identity ladder resolving for j:
            <br/><br/>

            \begin{align*}
            j_1 &= i_0 - bi_1 + mj_0 \\
            j_2 &= i_1 - bi_2 + mj_1 \\
            j_3 &= i_2 - bi_3 + mj_2 \\
            j_4 &= i_3 - bi_4 + mj_3 \\
            &... \\
            j_{p-1} &= i_{p-2} - bi_{p-1} + mj_{p-2} \\
            j_0 &= i_{p-1} - bi_0 + mj_{p-1}
            \end{align*}
        </div>
        <hr class="pagebreak"/>
        <div>
            Build out 1:
            <br/><br/>

            \begin{align*}
            j_1 &= i_{0} - bi_1 + mj_{0} \\
            \end{align*}

            <br/><br/>
        </div>
        <div>
            Build out 2:
            <br/><br/>

            \begin{align*}
            j_2 &= i_1 - bi_2 + mj_1 \\
            j_2 &= i_1 - bi_2 + m(i_0 - bi_1 + mj_0) \\
            j_2 &= i_1 - bi_2 + mi_0 - mbi_1 + m^2j_0 \\
            j_2 &= (1-mb)i_1 - bi_2 + mi_0 + m^2j_0
            \end{align*}

            <br/><br/>
        </div>
        <div>
            Build out 3:
            <br/><br/>

            \begin{align*}
            j_3 &= i_2 - bi_3 + mj_2 \\
            j_3 &= i_2 - bi_3 + m((1-mb)i_1 - bi_2 + mi_0 + m^2j_0) \\
            j_3 &= i_2 - bi_3 + m(1-mb)i_1 - mbi_2 + m^2i_0 + m^3j_0 \\
            j_3 &= (1-mb)i_2 + m(1-mb)i_1 - bi_3 + m^2i_0 + m^3j_0
            \end{align*}

            <br/><br/>
        </div>
        <div>
            Build out 4:
            <br/><br/>

            \begin{align*}
            j_4 &= i_3 - bi_4 + mj_3 \\
            j_4 &= i_3 - bi_4 + m((1-mb)i_2 + m(1-mb)i_1 - bi_3 + m^2i_0 + m^3j_0) \\
            j_4 &= i_3 - bi_4 + m(1-mb)i_2 + m^2(1-mb)i_1 - mbi_3 + m^3i_0 + m^4j_0 \\
            j_4 &= (1-mb)i_3  + m(1-mb)i_2 + m^2(1-mb)i_1 -bi_4 + m^3i_0 + m^4j_0
            \end{align*}

            <br/><br/>
        </div>
        <div>
            Build out 5:
            <br/><br/>

            \begin{align*}
            j_5 &= i_4 - bi_5 + mj_4 \\
            j_5 &= i_4 - bi_5 + m((1-mb)i_3  + m(1-mb)i_2 + m^2(1-mb)i_1 - bi_4 + m^3i_0 + m^4j_0) \\
            j_5 &= i_4 - bi_5 + m(1-mb)i_3  + m^2(1-mb)i_2 + m^3(1-mb)i_1 - mbi_4 + m^4i_0 + m^5j_0) \\
            j_5 &= (1 - mb)i_4 + m(1-mb)i_3  + m^2(1-mb)i_2 + m^3(1-mb)i_1 - bi_5 + m^4i_0 + m^5j_0) \\
            j_5 &= (1 - mb)\sum_{k=0}^{5-2} m^{5-k-1}i_k - bi_5 + m^4i_0 + m^5j_0 \\
            \end{align*}

            <br/><br/>
        </div>
        <hr class="pagebreak"/>
        <div>
            Generalize for <code>n</code>:

            \begin{align*}
            j_n &= (1-mb)\sum_{k=0}^{n-2} m^{n-k-1}i_k - bi_n + m^{n-1}i_0 + m^nj_0 \\
            j_n &= (1-mb)\sum_{k=0}^{n-2} m^{n-k-1}i_k - bi_n + m^{n-1}i_0 + m^n(i_{p-1} - bi_0 + mj_{p-1}) \\
            \end{align*}

            Let <code>n</code> become <code>p</code>:

            \begin{align*}
            j_p &= (1-mb)\sum_{k=0}^{p-2} m^{p-k-1}i_k - bi_p + m^{p-1}i_0 + m^pi_{p-1} - m^pbi_0 + m^{p+1}j_{p-1} \\
            j_p &= (1-mb)\sum_{k=0}^{p-2} m^{p-k-1}i_k - bi_p + m^{p-1}(1 - mb)i_0 + m^p(i_{p-1} + mj_{p-1}) \\
            \end{align*}

            Complete the sum:

            \begin{align*}
            j_p &= (1-mb)(\sum_{k=0}^{p-2} m^{p-k-1}i_k + m^{p-1}i_0) - bi_p + m^p(i_{p-1} + mj_{p-1}) \\
            j_p &= (1-mb)\sum_{k=0}^{p-1} m^{p-k-1}i_k - bi_p + m^p(i_{p-1} + mj_{p-1}) \\
            \end{align*}
        </div>
        <hr/>
        <div>
            Bring the sum to the left hand side:

            \begin{align*}
            (mb-1)\sum_{k=0}^{p-1} m^{p-k-1}i_k &= m^p(i_{p-1} + mj_{p-1}) - (bi_p + j_p) \\
            \end{align*}
            \begin{align}
            \sum_{k=0}^{p-1} m^{p-k-1}i_k &= { m^p(i_{p-1} + mj_{p-1}) - (bi_p + j_p) \over (mb-1) }
            \end{align}
        </div>
        <hr/>
        <div>
            Substitute <code>( bi<sub>0</sub> + j<sub>0</sub> )</code>
            for both <code>( bi<sub>p</sub> + j<sub>p</sub> )</code>
            and <code>( i<sub>p-1</sub> + mj<sub>p-1</sub> )</code>

            \begin{align*}
            \sum_{k=0}^{p-1} m^{p-k-1}i_k &= { m^p(i_{p-1} + mj_{p-1}) - (bi_p + j_p) \over (mb-1) } \\
            \sum_{k=0}^{p-1} m^{p-k-1}i_k &= { m^p(bi_0 + j_0) - (bi_0 + j_0) \over (mb-1) } \\
            \end{align*}
        </div>
        <hr/>
        <div>
            The choice of <code>( i<sub>0</sub>, j<sub>0</sub> )</code> is arbitrary,
            so this is true for every choice:

            \begin{align}
            \sum_{k=0}^{p-1} m^{p-k-1}i_k &= (bi_0 + j_0){ (m^p - 1) \over (mb-1) } \\
            \end{align}

            By symmetry:
            \begin{align}
            \sum_{k=0}^{p-1} b^{p-k-1}j_k &= (mj_0 + i_0){ (b^p - 1) \over (mb-1) } \\
            \end{align}
        </div>
        <hr class="pagebreak"/>
        <div>
            For any \( b, m > 1 \), three characteristic natural numbers \( p, C, D \) occur:

            \begin{matrix}
            p < (mb - 1), & C = \frac { m^{p} - 1 } { (mb - 1)}, & D = \frac { b^{p} - 1 } { (mb - 1)}
            \end{matrix}

            <br/>

            <b>Read right:</b>
            choose any <code>(i, j)</code>,
            follow the chain for <code>p</code> steps,
            collect the <code>i</code> values in sequence.<br/>

            <br/>

            \begin{align}
            \sum_{k=0}^{p-1} m^{p-k-1}i_k &= (bi + j)C \\
            \end{align}

            <br/>

            <b>Read left:</b>
            choose any <code>(i, j)</code>,
            follow the chain in reverse for <code>p</code> steps,
            collect the <code>j</code> values in sequence.<br/>

            <br/>

            \begin{align}
            \sum_{k=0}^{p-1} b^kj_{p-k-1} &= (i + mj)D \\
            \end{align}
        </div>
        <hr/>
        <div>
            For all b,m the chain from <code>(0,1)</code> has:

            \begin{align*}
                i_0 &= 0,& j_0 &= 1 \\
                i_{p-1} &= 1,& j_{p-1} &= 0 \\
            \end{align*}

            The sequence of <code>i</code> values, from (0,1), interpreted as a number in base <code>m</code>
            is equal to <code>C</code>.

            \begin{align}
            1 + \sum_{k=1}^{p-2} m^{p-k-2}i_k &= { m^p - 1 \over mb - 1 } &= C \\
            \end{align}
            <br/>

            The sequence of <code>j</code> values, in reverse from (1,0), interpreted as a number in base <code>b</code>
            is equal to <code>D</code>:

            \begin{align}
            1 + \sum_{k=1}^{p-2} b^{k-1}j_{p-k-2} &= { b^p - 1 \over mb - 1 } &= D \\
            \end{align}
        </div>
        <hr/>
        <div>
            For all b & m, chain <code>(m-1,b-1)</code>, as expected, has:

            \begin{align*}
            i &= m-1  \\
            j &= b-1 \\
            \sum_{k=0}^{p-1} m^k(m-1) &= (mb - 1 )C \\
            \sum_{k=0}^{p-1} m^k(m-1) &= m^p - 1 \\
            \end{align*}
        </div>

    </body>
</html>
